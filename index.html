<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task List</title><!-- Updated dynamically by JS -->
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            min-height: 100vh;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }
        .task-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .task {
            display: flex;
            align-items: center;
            padding: 16px;
            background: white;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .task:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        .task:active {
            transform: translateY(0);
        }
        .task-icon {
            font-size: 1.25rem;
            margin-right: 12px;
            width: 24px;
            text-align: center;
        }
        .task-name {
            flex: 1;
            font-size: 1rem;
        }
        /* Status: not-started */
        .task.not-started .task-icon {
            color: #999;
        }
        .task.not-started .task-name {
            color: #666;
        }
        /* Status: in-progress */
        .task.in-progress {
            background: #fff8e1;
            border-left: 4px solid #ff9800;
        }
        .task.in-progress .task-icon {
            color: #ff9800;
        }
        .task.in-progress .task-name {
            color: #e65100;
            font-weight: 500;
        }
        /* Status: done */
        .task.done .task-icon {
            color: #4caf50;
        }
        .task.done .task-name {
            color: #999;
            text-decoration: line-through;
        }
        /* Status: needs-review */
        .task.needs-review {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }
        .task.needs-review .task-icon {
            color: #2196f3;
        }
        .task.needs-review .task-name {
            color: #1976d2;
            font-weight: 500;
        }
        /* Status: removed */
        .task.removed {
            background: #ffebee;
            opacity: 0.6;
        }
        .task.removed .task-icon {
            color: #d32f2f;
        }
        .task.removed .task-name {
            color: #999;
            text-decoration: line-through;
        }
        .loading, .error {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .error {
            color: #d32f2f;
        }
        .saving-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.875rem;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .saving-indicator.visible {
            opacity: 1;
        }
        /* Add task form */
        .add-task-form {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        .add-task-input {
            flex: 1;
            padding: 12px 16px;
            font-size: 1rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.2s;
        }
        .add-task-input:focus {
            border-color: #2196f3;
        }
        .add-task-btn {
            padding: 12px 24px;
            font-size: 1rem;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .add-task-btn:hover {
            background: #1976d2;
        }
        .add-task-btn:active {
            background: #1565c0;
        }
        /* Tag groups */
        .tag-group {
            margin-bottom: 24px;
        }
        .tag-group-header {
            display: flex;
            align-items: center;
            padding: 8px 0;
            margin-bottom: 8px;
            border-bottom: 2px solid #ddd;
        }
        .tag-group-name {
            font-size: 0.875rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .tag-group-count {
            margin-left: 8px;
            font-size: 0.75rem;
            color: #999;
            font-weight: normal;
        }
        /* Task tags */
        .task-tags {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }
        .task-tag {
            font-size: 0.7rem;
            padding: 2px 6px;
            background: #e0e0e0;
            color: #666;
            border-radius: 4px;
            cursor: pointer;
        }
        .task-tag:hover {
            background: #bdbdbd;
        }
        .add-tag-btn {
            font-size: 0.7rem;
            padding: 2px 6px;
            background: transparent;
            color: #999;
            border: 1px dashed #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
        .add-tag-btn:hover {
            background: #f5f5f5;
            color: #666;
        }
        /* Tag input modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-overlay.visible {
            display: flex;
        }
        .modal {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            min-width: 300px;
        }
        .modal h3 {
            margin: 0 0 16px 0;
            color: #333;
        }
        .modal input {
            width: 100%;
            padding: 12px;
            font-size: 1rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 16px;
            outline: none;
        }
        .modal input:focus {
            border-color: #2196f3;
        }
        .modal-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        .modal-btn {
            padding: 8px 16px;
            font-size: 0.875rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        .modal-btn.primary {
            background: #2196f3;
            color: white;
        }
        .modal-btn.secondary {
            background: #e0e0e0;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tasks <span id="listNameDisplay" style="font-weight: normal; color: #666; font-size: 0.8em;"></span></h1>
        <form class="add-task-form" id="addTaskForm">
            <input type="text" class="add-task-input" id="taskInput" placeholder="Add a new task..." required>
            <button type="submit" class="add-task-btn">Add</button>
        </form>
        <div id="taskList">
            <div class="loading">Loading tasks...</div>
        </div>
    </div>
    <div class="saving-indicator" id="savingIndicator">Saving...</div>
    
    <!-- Tag input modal -->
    <div class="modal-overlay" id="tagModal">
        <div class="modal">
            <h3>Add Tag</h3>
            <input type="text" id="tagInput" placeholder="Enter tag name...">
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="cancelTagBtn">Cancel</button>
                <button class="modal-btn primary" id="saveTagBtn">Add</button>
            </div>
        </div>
    </div>
    <div class="saving-indicator" id="savingIndicator">Saving...</div>

    <script src="config.js"></script>
    <script src="task-mutations.js"></script>
    <script src="task-store.js"></script>
    <script>
        // ===========================================
        // URL Parameter Handling
        // ===========================================
        
        /**
         * Get list name from URL query param, fallback to config default
         * @returns {string} - The list name to use
         */
        function getListName() {
            const params = new URLSearchParams(window.location.search);
            const list = params.get('list');
            return (list && list.trim()) || CONFIG.DEFAULT_LIST_NAME;
        }

        // Use config from config.js
        const API_BASE = CONFIG.API_BASE;
        const LIST_NAME = getListName();
        const IS_MOCK = API_BASE === 'mock';

        // Mock data for local testing
        const MOCK_TASKS = [
            { name: 'Set up project structure', status: 'done', tags: ['backend'] },
            { name: 'Create basic UI components', status: 'done', tags: ['frontend'] },
            { name: 'Implement API integration', status: 'in-progress', tags: ['backend', 'frontend'] },
            { name: 'Add authentication', status: 'needs-review', tags: ['backend'] },
            { name: 'Write unit tests', status: 'not-started', tags: ['testing'] },
            { name: 'Deploy to production', status: 'not-started' },
            { name: 'Old feature removed', status: 'removed' }
        ];

        // State (UI-only state, task state is in TaskStore)
        let isSaving = false;
        let editingTagIndex = null; // Track which task is being edited for tags

        // Destructure TaskStore for convenience
        const { 
            getTasks, setTasks, getTask, getStatusCycle,
            addTask, updateTaskStatus, addTagToTask, removeTagFromTask, cycleTaskStatus 
        } = TaskStore;

        // Status icons
        const statusIcons = {
            'not-started': '○',
            'in-progress': '◐',
            'needs-review': '?',
            'done': '✓',
            'removed': '✕'
        };

        // DOM elements
        const taskListEl = document.getElementById('taskList');
        const savingIndicator = document.getElementById('savingIndicator');
        const addTaskForm = document.getElementById('addTaskForm');
        const taskInput = document.getElementById('taskInput');
        const tagModal = document.getElementById('tagModal');
        const tagInput = document.getElementById('tagInput');
        const saveTagBtn = document.getElementById('saveTagBtn');
        const cancelTagBtn = document.getElementById('cancelTagBtn');

        // Fetch tasks from API (or mock)
        async function fetchTasks() {
            if (IS_MOCK) {
                // Load from localStorage or use default mock data
                const saved = localStorage.getItem('mockTasks');
                setTasks(saved ? JSON.parse(saved) : [...MOCK_TASKS]);
                renderTasks();
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/${LIST_NAME}`);
                if (response.status === 404) {
                    // List doesn't exist - create it
                    const createResponse = await fetch(`${API_BASE}/${LIST_NAME}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: '[]'
                    });
                    if (!createResponse.ok) throw new Error('Failed to create list');
                    setTasks([]);
                    renderTasks();
                    return;
                }
                if (!response.ok) throw new Error('Failed to fetch tasks');
                setTasks(await response.json());
                renderTasks();
            } catch (error) {
                taskListEl.innerHTML = `<li class="error">Error loading tasks: ${error.message}</li>`;
            }
        }

        // Save tasks to API (or mock)
        // Flow: GET latest → apply mutation → PUT → update local state → re-render
        // @param {Object} mutation - {fn: string, args: array} describing the mutation to apply
        async function saveTasks(mutation) {
            if (IS_MOCK) {
                localStorage.setItem('mockTasks', JSON.stringify(getTasks()));
                // Brief visual feedback
                savingIndicator.classList.add('visible');
                setTimeout(() => savingIndicator.classList.remove('visible'), 300);
                return;
            }
            
            if (isSaving) return;
            isSaving = true;
            savingIndicator.classList.add('visible');
            
            try {
                // 1. GET latest server data
                const getResponse = await fetch(`${API_BASE}/${LIST_NAME}`);
                if (!getResponse.ok) throw new Error('Failed to fetch latest tasks');
                const serverTasks = await getResponse.json();
                
                // 2. Apply the mutation to server data
                if (mutation) {
                    TaskMutations.applyMutation(serverTasks, mutation);
                }
                
                // 3. PUT the merged result
                const putResponse = await fetch(`${API_BASE}/${LIST_NAME}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(serverTasks)
                });
                if (!putResponse.ok) throw new Error('Failed to save');
                
                // 4. Update local state with the merged result
                setTasks(serverTasks);
                
                // 5. Re-render to reflect any server-side changes we merged in
                renderTasks();
            } catch (error) {
                console.error('Save error:', error);
            } finally {
                isSaving = false;
                savingIndicator.classList.remove('visible');
            }
        }

        // Render tasks grouped by tags
        function renderTasks() {
            const tasks = getTasks();
            if (tasks.length === 0) {
                taskListEl.innerHTML = '<div class="loading">No tasks found</div>';
                return;
            }

            // Collect all unique tags and group tasks
            const tagGroups = new Map();
            const untaggedTasks = [];
            
            tasks.forEach((task, index) => {
                if (task.tags && task.tags.length > 0) {
                    task.tags.forEach(tag => {
                        if (!tagGroups.has(tag)) {
                            tagGroups.set(tag, []);
                        }
                        tagGroups.get(tag).push({ task, index });
                    });
                } else {
                    untaggedTasks.push({ task, index });
                }
            });

            // Sort tags alphabetically
            const sortedTags = Array.from(tagGroups.keys()).sort();
            
            let html = '';
            
            // Render each tag group
            sortedTags.forEach(tag => {
                const groupTasks = tagGroups.get(tag);
                html += renderTagGroup(tag, groupTasks);
            });
            
            // Render untagged group at the end
            if (untaggedTasks.length > 0) {
                html += renderTagGroup('Untagged', untaggedTasks);
            }

            taskListEl.innerHTML = html;
        }

        // Render a single tag group
        function renderTagGroup(tagName, groupTasks) {
            const tasksHtml = groupTasks.map(({ task, index }) => `
                <li class="task ${task.status}" data-index="${index}">
                    <span class="task-icon">${statusIcons[task.status] || '○'}</span>
                    <span class="task-name">${escapeHtml(task.name)}</span>
                    <div class="task-tags">
                        ${(task.tags || []).map(t => `<span class="task-tag" data-index="${index}" data-tag="${escapeHtml(t)}">${escapeHtml(t)}</span>`).join('')}
                        <button class="add-tag-btn" data-index="${index}">+</button>
                    </div>
                </li>
            `).join('');

            return `
                <div class="tag-group">
                    <div class="tag-group-header">
                        <span class="tag-group-name">${escapeHtml(tagName)}</span>
                        <span class="tag-group-count">(${groupTasks.length})</span>
                    </div>
                    <ul class="task-list">${tasksHtml}</ul>
                </div>
            `;
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Handle task click - cycle status
        taskListEl.addEventListener('click', (e) => {
            // Handle add tag button
            if (e.target.classList.contains('add-tag-btn')) {
                e.stopPropagation();
                editingTagIndex = parseInt(e.target.dataset.index, 10);
                tagInput.value = '';
                tagModal.classList.add('visible');
                tagInput.focus();
                return;
            }
            
            // Handle tag click (remove tag)
            if (e.target.classList.contains('task-tag')) {
                e.stopPropagation();
                const taskId = parseInt(e.target.dataset.index, 10);
                const tag = e.target.dataset.tag;
                removeTagFromTask(taskId, tag);
                renderTasks();
                saveTasks({ fn: 'removeTagFromTask', args: [taskId, tag] });
                return;
            }
            
            const taskEl = e.target.closest('.task');
            if (!taskEl) return;

            const taskId = parseInt(taskEl.dataset.index, 10);
            cycleTaskStatus(taskId);
            renderTasks();
            saveTasks({ fn: 'cycleTaskStatus', args: [taskId] });
        });

        // Handle add task
        addTaskForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const name = taskInput.value.trim();
            if (!name) return;

            addTask(name);
            taskInput.value = '';
            renderTasks();
            saveTasks({ fn: 'addTask', args: [name] });
        });

        // Tag modal handlers
        function closeTagModal() {
            tagModal.classList.remove('visible');
            editingTagIndex = null;
        }

        cancelTagBtn.addEventListener('click', closeTagModal);
        
        tagModal.addEventListener('click', (e) => {
            if (e.target === tagModal) closeTagModal();
        });

        saveTagBtn.addEventListener('click', () => {
            const tag = tagInput.value.trim().toLowerCase();
            if (!tag || editingTagIndex === null) return;
            
            if (addTagToTask(editingTagIndex, tag)) {
                renderTasks();
                saveTasks({ fn: 'addTagToTask', args: [editingTagIndex, tag] });
            }
            closeTagModal();
        });

        tagInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveTagBtn.click();
            } else if (e.key === 'Escape') {
                closeTagModal();
            }
        });

        // Initialize
        document.title = `${LIST_NAME} - Task List`;
        document.getElementById('listNameDisplay').textContent = `(${LIST_NAME})`;
        fetchTasks();
    </script>
</body>
</html>
